diff --git a/node_modules/@helia/verified-fetch/dist/src/utils/content-type-parser.js b/node_modules/@helia/verified-fetch/dist/src/utils/content-type-parser.js
index 242f8d5..058c731 100644
--- a/node_modules/@helia/verified-fetch/dist/src/utils/content-type-parser.js
+++ b/node_modules/@helia/verified-fetch/dist/src/utils/content-type-parser.js
@@ -1,3 +1,4 @@
+// @ts-check
 import { logger } from '@libp2p/logger';
 import { fileTypeFromBuffer } from 'file-type';
 const log = logger('helia:verified-fetch:content-type-parser');
@@ -17,6 +18,20 @@ async function checkForJson(bytes) {
         return false;
     }
 }
+async function checkForHtml(bytes) {
+  log('checking for html');
+  return /^\s*<(?:!doctype\s+html|html|head|body)\b/i.test(new TextDecoder().decode(bytes.slice(0, 64)));
+}
+async function checkForUtf8Text(bytes) {
+  log('checking for text');
+  try {
+    // The 'fatal' option ensures an error is thrown if any invalid UTF-8 bytes are found.
+    new TextDecoder("utf-8", { fatal: true }).decode(bytes);
+    return true;
+  } catch {
+    return false;
+  }
+}
 export async function contentTypeParser(bytes, fileName) {
     log('contentTypeParser called for fileName: %s, byte size=%s', fileName, bytes.length);
     const detectedType = (await fileTypeFromBuffer(bytes))?.mime;
@@ -32,6 +47,10 @@ export async function contentTypeParser(bytes, fileName) {
         }
         else if (await checkForJson(bytes)) {
             return 'application/json';
+        } else if (await checkForHtml(bytes)) {
+            return 'text/html; charset=utf-8';
+        } else if (await checkForUtf8Text(bytes)) {
+            return 'text/plain; charset=utf-8';
         }
         return defaultMimeType;
     }
